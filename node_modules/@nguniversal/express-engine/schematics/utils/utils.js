"use strict";
/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.addInitialNavigation = exports.getImportOfIdentifier = exports.findImport = exports.getOutputPath = exports.stripTsExtension = exports.getProject = void 0;
const schematics_1 = require("@angular-devkit/schematics");
const utility_1 = require("@schematics/angular/utility");
const ts = require("typescript");
async function getProject(host, projectName) {
    const workspace = await (0, utility_1.readWorkspace)(host);
    const project = workspace.projects.get(projectName);
    if (!project || project.extensions.projectType !== 'application') {
        throw new schematics_1.SchematicsException(`Universal requires a project type of 'application'.`);
    }
    return project;
}
exports.getProject = getProject;
function stripTsExtension(file) {
    return file.replace(/\.ts$/, '');
}
exports.stripTsExtension = stripTsExtension;
async function getOutputPath(host, projectName, target) {
    // Generate new output paths
    const project = await getProject(host, projectName);
    const serverTarget = project.targets.get(target);
    if (!serverTarget || !serverTarget.options) {
        throw new schematics_1.SchematicsException(`Cannot find 'options' for ${projectName} ${target} target.`);
    }
    const { outputPath } = serverTarget.options;
    if (typeof outputPath !== 'string') {
        throw new schematics_1.SchematicsException(`outputPath for ${projectName} ${target} target is not a string.`);
    }
    return outputPath;
}
exports.getOutputPath = getOutputPath;
function findImport(sourceFile, moduleName, symbolName) {
    // Only look through the top-level imports.
    for (const node of sourceFile.statements) {
        if (!ts.isImportDeclaration(node) ||
            !ts.isStringLiteral(node.moduleSpecifier) ||
            node.moduleSpecifier.text !== moduleName) {
            continue;
        }
        const namedBindings = node.importClause && node.importClause.namedBindings;
        if (!namedBindings || !ts.isNamedImports(namedBindings)) {
            continue;
        }
        if (namedBindings.elements.some((element) => element.name.text === symbolName)) {
            return namedBindings;
        }
    }
    return null;
}
exports.findImport = findImport;
/** Gets import information about the specified identifier by using the Type checker. */
function getImportOfIdentifier(typeChecker, node) {
    const symbol = typeChecker.getSymbolAtLocation(node);
    if (!symbol || !symbol.declarations.length) {
        return null;
    }
    const decl = symbol.declarations[0];
    if (!ts.isImportSpecifier(decl)) {
        return null;
    }
    const importDecl = decl.parent.parent.parent;
    if (!ts.isStringLiteral(importDecl.moduleSpecifier)) {
        return null;
    }
    return {
        // Handles aliased imports: e.g. "import {Component as myComp} from ...";
        name: decl.propertyName ? decl.propertyName.text : decl.name.text,
        importModule: importDecl.moduleSpecifier.text,
        node: importDecl,
    };
}
exports.getImportOfIdentifier = getImportOfIdentifier;
function addInitialNavigation(node) {
    const existingOptions = node.arguments[1];
    // If the user has explicitly set initialNavigation, we respect that
    if (existingOptions &&
        existingOptions.properties.some((exp) => ts.isPropertyAssignment(exp) &&
            ts.isIdentifier(exp.name) &&
            exp.name.text === 'initialNavigation')) {
        return node;
    }
    const enabledLiteral = ts.createStringLiteral('enabledBlocking');
    // TypeScript will emit the Node with double quotes.
    // In schematics we usually write code with a single quotes
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    enabledLiteral.singleQuote = true;
    const initialNavigationProperty = ts.createPropertyAssignment('initialNavigation', enabledLiteral);
    const routerOptions = existingOptions
        ? ts.updateObjectLiteral(existingOptions, ts.createNodeArray([...existingOptions.properties, initialNavigationProperty]))
        : ts.createObjectLiteral([initialNavigationProperty], true);
    const args = [node.arguments[0], routerOptions];
    return ts.createCall(node.expression, node.typeArguments, args);
}
exports.addInitialNavigation = addInitialNavigation;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidXRpbHMuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi8uLi9tb2R1bGVzL2V4cHJlc3MtZW5naW5lL3NjaGVtYXRpY3MvdXRpbHMvdXRpbHMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBOzs7Ozs7R0FNRzs7O0FBR0gsMkRBQWlFO0FBRWpFLHlEQUE0RDtBQUM1RCxpQ0FBaUM7QUFFMUIsS0FBSyxVQUFVLFVBQVUsQ0FDOUIsSUFBVSxFQUNWLFdBQW1CO0lBRW5CLE1BQU0sU0FBUyxHQUFHLE1BQU0sSUFBQSx1QkFBYSxFQUFDLElBQUksQ0FBQyxDQUFDO0lBQzVDLE1BQU0sT0FBTyxHQUFHLFNBQVMsQ0FBQyxRQUFRLENBQUMsR0FBRyxDQUFDLFdBQVcsQ0FBQyxDQUFDO0lBRXBELElBQUksQ0FBQyxPQUFPLElBQUksT0FBTyxDQUFDLFVBQVUsQ0FBQyxXQUFXLEtBQUssYUFBYSxFQUFFO1FBQ2hFLE1BQU0sSUFBSSxnQ0FBbUIsQ0FBQyxxREFBcUQsQ0FBQyxDQUFDO0tBQ3RGO0lBRUQsT0FBTyxPQUFPLENBQUM7QUFDakIsQ0FBQztBQVpELGdDQVlDO0FBRUQsU0FBZ0IsZ0JBQWdCLENBQUMsSUFBWTtJQUMzQyxPQUFPLElBQUksQ0FBQyxPQUFPLENBQUMsT0FBTyxFQUFFLEVBQUUsQ0FBQyxDQUFDO0FBQ25DLENBQUM7QUFGRCw0Q0FFQztBQUVNLEtBQUssVUFBVSxhQUFhLENBQ2pDLElBQVUsRUFDVixXQUFtQixFQUNuQixNQUEwQjtJQUUxQiw0QkFBNEI7SUFDNUIsTUFBTSxPQUFPLEdBQUcsTUFBTSxVQUFVLENBQUMsSUFBSSxFQUFFLFdBQVcsQ0FBQyxDQUFDO0lBQ3BELE1BQU0sWUFBWSxHQUFHLE9BQU8sQ0FBQyxPQUFPLENBQUMsR0FBRyxDQUFDLE1BQU0sQ0FBQyxDQUFDO0lBQ2pELElBQUksQ0FBQyxZQUFZLElBQUksQ0FBQyxZQUFZLENBQUMsT0FBTyxFQUFFO1FBQzFDLE1BQU0sSUFB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QUFDLFlBQVksQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDO1lBQ3pCLEdBQUcsQ0FBQyxJQUFJLENBQUMsSUFBSSxLQUFLLG1CQUFtQixDQUN4QyxFQUNEO1FBQ0EsT0FBTyxJQUFJLENBQUM7S0FDYjtJQUVELE1BQU0sY0FBYyxHQUFHLEVBQUUsQ0FBQyxtQkFBbUIsQ0FBQyxpQkFBaUIsQ0FBQyxDQUFDO0lBQ2pFLG9EQUFvRDtJQUNwRCwyREFBMkQ7SUFDM0QsOERBQThEO0lBQzdELGNBQXNCLENBQUMsV0FBVyxHQUFHLElBQUksQ0FBQztJQUUzQyxNQUFNLHlCQUF5QixHQUFHLEVBQUUsQ0FBQyx3QkFBd0IsQ0FDM0QsbUJBQW1CLEVBQ25CLGNBQWMsQ0FDZixDQUFDO0lBQ0YsTUFBTSxhQUFhLEdBQUcsZUFBZTtRQUNuQyxDQUFDLENBQUMsRUFBRSxDQUFDLG1CQUFtQixDQUNwQixlQUFlLEVBQ2YsRUFBRSxDQUFDLGVBQWUsQ0FBQyxDQUFDLEdBQUcsZUFBZSxDQUFDLFVBQVUsRUFBRSx5QkFBeUIsQ0FBQyxDQUFDLENBQy9FO1FBQ0gsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxtQkFBbUIsQ0FBQyxDQUFDLHlCQUF5QixDQUFDLEVBQUUsSUFBSSxDQUFDLENBQUM7SUFDOUQsTUFBTSxJQUFJLEdBQUcsQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxFQUFFLGFBQWEsQ0FBQyxDQUFDO0lBRWhELE9BQU8sRUFBRSxDQUFDLFVBQVUsQ0FBQyxJQUFJLENBQUMsVUFBVSxFQUFFLElBQUksQ0FBQyxhQUFhLEVBQUUsSUFBSSxDQUFDLENBQUM7QUFDbEUsQ0FBQztBQW5DRCxvREFtQ0MiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIExMQyBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cblxuaW1wb3J0IHsgd29ya3NwYWNlcyB9IGZyb20gJ0Bhbmd1bGFyLWRldmtpdC9jb3JlJztcbmltcG9ydCB7IFNjaGVtYXRpY3NFeGNlcHRpb24gfSBmcm9tICdAYW5ndWxhci1kZXZraXQvc2NoZW1hdGljcyc7XG5pbXBvcnQgeyBUcmVlIH0gZnJvbSAnQGFuZ3VsYXItZGV2a2l0L3NjaGVtYXRpY3Mvc3JjL3RyZWUvaW50ZXJmYWNlJztcbmltcG9ydCB7IHJlYWRXb3Jrc3BhY2UgfSBmcm9tICdAc2NoZW1hdGljcy9hbmd1bGFyL3V0aWxpdHknO1xuaW1wb3J0ICogYXMgdHMgZnJvbSAndHlwZXNjcmlwdCc7XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRQcm9qZWN0KFxuICBob3N0OiBUcmVlLFxuICBwcm9qZWN0TmFtZTogc3RyaW5nLFxuKTogUHJvbWlzZTx3b3Jrc3BhY2VzLlByb2plY3REZWZpbml0aW9uPiB7XG4gIGNvbnN0IHdvcmtzcGFjZSA9IGF3YWl0IHJlYWRXb3Jrc3BhY2UoaG9zdCk7XG4gIGNvbnN0IHByb2plY3QgPSB3b3Jrc3BhY2UucHJvamVjdHMuZ2V0KHByb2plY3ROYW1lKTtcblxuICBpZiAoIXByb2plY3QgfHwgcHJvamVjdC5leHRlbnNpb25zLnByb2plY3RUeXBlICE9PSAnYXBwbGljYXRpb24nKSB7XG4gICAgdGhyb3cgbmV3IFNjaGVtYXRpY3NFeGNlcHRpb24oYFVuaXZlcnNhbCByZXF1aXJlcyBhIHByb2plY3QgdHlwZSBvZiAnYXBwbGljYXRpb24nLmApO1xuICB9XG5cbiAgcmV0dXJuIHByb2plY3Q7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzdHJpcFRzRXh0ZW5zaW9uKGZpbGU6IHN0cmluZyk6IHN0cmluZyB7XG4gIHJldHVybiBmaWxlLnJlcGxhY2UoL1xcLnRzJC8sICcnKTtcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldE91dHB1dFBhdGgoXG4gIGhvc3Q6IFRyZWUsXG4gIHByb2plY3ROYW1lOiBzdHJpbmcsXG4gIHRhcmdldDogJ3NlcnZlcicgfCAnYnVpbGQnLFxuKTogUHJvbWlzZTxzdHJpbmc+IHtcbiAgLy8gR2VuZXJhdGUgbmV3IG91dHB1dCBwYXRoc1xuICBjb25zdCBwcm9qZWN0ID0gYXdhaXQgZ2V0UHJvamVjdChob3N0LCBwcm9qZWN0TmFtZSk7XG4gIGNvbnN0IHNlcnZlclRhcmdldCA9IHByb2plY3QudGFyZ2V0cy5nZXQodGFyZ2V0KTtcbiAgaWYgKCFzZXJ2ZXJUYXJnZXQgfHwgIXNlcnZlclRhcmdldC5vcHRpb25zKSB7XG4gICAgdGhyb3cgbmV3IFNjaGVtYXRpY3NFeGNlcHRpb24oYENhbm5vdCBmaW5kICdvcHRpb25zJyBmb3IgJHtwcm9qZWN0TmFtZX0gJHt0YXJnZXR9IHRhcmdldC5gKTtcbiAgfVxuXG4gIGNvbnN0IHsgb3V0cHV0UGF0aCB9ID0gc2VydmVyVGFyZ2V0Lm9wdGlvbnM7XG4gIGlmICh0eXBlb2Ygb3V0cHV0UGF0aCAhPT0gJ3N0cmluZycpIHtcbiAgICB0aHJvdyBuZXcgU2NoZW1hdGljc0V4Y2VwdGlvbihcbiAgICAgIGBvdXRwdXRQYXRoIGZvciAke3Byb2plY3ROYW1lfSAke3RhcmdldH0gdGFyZ2V0IGlzIG5vdCBhIHN0cmluZy5gLFxuICAgICk7XG4gIH1cblxuICByZXR1cm4gb3V0cHV0UGF0aDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGZpbmRJbXBvcnQoXG4gIHNvdXJjZUZpbGU6IHRzLlNvdXJjZUZpbGUsXG4gIG1vZHVsZU5hbWU6IHN0cmluZyxcbiAgc3ltYm9sTmFtZTogc3RyaW5nLFxuKTogdHMuTmFtZWRJbXBvcnRzIHwgbnVsbCB7XG4gIC8vIE9ubHkgbG9vayB0aHJvdWdoIHRoZSB0b3AtbGV2ZWwgaW1wb3J0cy5cbiAgZm9yIChjb25zdCBub2RlIG9mIHNvdXJjZUZpbGUuc3RhdGVtZW50cykge1xuICAgIGlmIChcbiAgICAgICF0cy5pc0ltcG9ydERlY2xhcmF0aW9uKG5vZGUpIHx8XG4gICAgICAhdHMuaXNTdHJpbmdMaXRlcmFsKG5vZGUubW9kdWxlU3BlY2lmaWVyKSB8fFxuICAgICAgbm9kZS5tb2R1bGVTcGVjaWZpZXIudGV4dCAhPT0gbW9kdWxlTmFtZVxuICAgICkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgY29uc3QgbmFtZWRCaW5kaW5ncyA9IG5vZGUuaW1wb3J0Q2xhdXNlICYmIG5vZGUuaW1wb3J0Q2xhdXNlLm5hbWVkQmluZGluZ3M7XG5cbiAgICBpZiAoIW5hbWVkQmluZGluZ3MgfHwgIXRzLmlzTmFtZWRJbXBvcnRzKG5hbWVkQmluZGluZ3MpKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBpZiAobmFtZWRCaW5kaW5ncy5lbGVtZW50cy5zb21lKChlbGVtZW50KSA9PiBlbGVtZW50Lm5hbWUudGV4dCA9PT0gc3ltYm9sTmFtZSkpIHtcbiAgICAgIHJldHVybiBuYW1lZEJpbmRpbmdzO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG5leHBvcnQgdHlwZSBJbXBvcnQgPSB7XG4gIG5hbWU6IHN0cmluZztcbiAgaW1wb3J0TW9kdWxlOiBzdHJpbmc7XG4gIG5vZGU6IHRzLkltcG9ydERlY2xhcmF0aW9uO1xufTtcblxuLyoqIEdldHMgaW1wb3J0IGluZm9ybWF0aW9uIGFib3V0IHRoZSBzcGVjaWZpZWQgaWRlbnRpZmllciBieSB1c2luZyB0aGUgVHlwZSBjaGVja2VyLiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldEltcG9ydE9mSWRlbnRpZmllcihcbiAgdHlwZUNoZWNrZXI6IHRzLlR5cGVDaGVja2VyLFxuICBub2RlOiB0cy5JZGVudGlmaWVyLFxuKTogSW1wb3J0IHwgbnVsbCB7XG4gIGNvbnN0IHN5bWJvbCA9IHR5cGVDaGVja2VyLmdldFN5bWJvbEF0TG9jYXRpb24obm9kZSk7XG5cbiAgaWYgKCFzeW1ib2wgfHwgIXN5bWJvbC5kZWNsYXJhdGlvbnMubGVuZ3RoKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBjb25zdCBkZWNsID0gc3ltYm9sLmRlY2xhcmF0aW9uc1swXTtcblxuICBpZiAoIXRzLmlzSW1wb3J0U3BlY2lmaWVyKGRlY2wpKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBjb25zdCBpbXBvcnREZWNsID0gZGVjbC5wYXJlbnQucGFyZW50LnBhcmVudDtcblxuICBpZiAoIXRzLmlzU3RyaW5nTGl0ZXJhbChpbXBvcnREZWNsLm1vZHVsZVNwZWNpZmllcikpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgLy8gSGFuZGxlcyBhbGlhc2VkIGltcG9ydHM6IGUuZy4gXCJpbXBvcnQge0NvbXBvbmVudCBhcyBteUNvbXB9IGZyb20gLi4uXCI7XG4gICAgbmFtZTogZGVjbC5wcm9wZXJ0eU5hbWUgPyBkZWNsLnByb3BlcnR5TmFtZS50ZXh0IDogZGVjbC5uYW1lLnRleHQsXG4gICAgaW1wb3J0TW9kdWxlOiBpbXBvcnREZWNsLm1vZHVsZVNwZWNpZmllci50ZXh0LFxuICAgIG5vZGU6IGltcG9ydERlY2wsXG4gIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhZGRJbml0aWFsTmF2aWdhdGlvbihub2RlOiB0cy5DYWxsRXhwcmVzc2lvbik6IHRzLkNhbGxFeHByZXNzaW9uIHtcbiAgY29uc3QgZXhpc3RpbmdPcHRpb25zID0gbm9kZS5hcmd1bWVudHNbMV0gYXMgdHMuT2JqZWN0TGl0ZXJhbEV4cHJlc3Npb24gfCB1bmRlZmluZWQ7XG5cbiAgLy8gSWYgdGhlIHVzZXIgaGFzIGV4cGxpY2l0bHkgc2V0IGluaXRpYWxOYXZpZ2F0aW9uLCB3ZSByZXNwZWN0IHRoYXRcbiAgaWYgKFxuICAgIGV4aXN0aW5nT3B0aW9ucyAmJlxuICAgIGV4aXN0aW5nT3B0aW9ucy5wcm9wZXJ0aWVzLnNvbWUoXG4gICAgICAoZXhwKSA9PlxuICAgICAgICB0cy5pc1Byb3BlcnR5QXNzaWdubWVudChleHApICYmXG4gICAgICAgIHRzLmlzSWRlbnRpZmllcihleHAubmFtZSkgJiZcbiAgICAgICAgZXhwLm5hbWUudGV4dCA9PT0gJ2luaXRpYWxOYXZpZ2F0aW9uJyxcbiAgICApXG4gICkge1xuICAgIHJldHVybiBub2RlO1xuICB9XG5cbiAgY29uc3QgZW5hYmxlZExpdGVyYWwgPSB0cy5jcmVhdGVTdHJpbmdMaXRlcmFsKCdlbmFibGVkQmxvY2tpbmcnKTtcbiAgLy8gVHlwZVNjcmlwdCB3aWxsIGVtaXQgdGhlIE5vZGUgd2l0aCBkb3VibGUgcXVvdGVzLlxuICAvLyBJbiBzY2hlbWF0aWNzIHdlIHVzdWFsbHkgd3JpdGUgY29kZSB3aXRoIGEgc2luZ2xlIHF1b3Rlc1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAoZW5hYmxlZExpdGVyYWwgYXMgYW55KS5zaW5nbGVRdW90ZSA9IHRydWU7XG5cbiAgY29uc3QgaW5pdGlhbE5hdmlnYXRpb25Qcm9wZXJ0eSA9IHRzLmNyZWF0ZVByb3BlcnR5QXNzaWdubWVudChcbiAgICAnaW5pdGlhbE5hdmlnYXRpb24nLFxuICAgIGVuYWJsZWRMaXRlcmFsLFxuICApO1xuICBjb25zdCByb3V0ZXJPcHRpb25zID0gZXhpc3RpbmdPcHRpb25zXG4gICAgPyB0cy51cGRhdGVPYmplY3RMaXRlcmFsKFxuICAgICAgICBleGlzdGluZ09wdGlvbnMsXG4gICAgICAgIHRzLmNyZWF0ZU5vZGVBcnJheShbLi4uZXhpc3RpbmdPcHRpb25zLnByb3BlcnRpZXMsIGluaXRpYWxOYXZpZ2F0aW9uUHJvcGVydHldKSxcbiAgICAgIClcbiAgICA6IHRzLmNyZWF0ZU9iamVjdExpdGVyYWwoW2luaXRpYWxOYXZpZ2F0aW9uUHJvcGVydHldLCB0cnVlKTtcbiAgY29uc3QgYXJncyA9IFtub2RlLmFyZ3VtZW50c1swXSwgcm91dGVyT3B0aW9uc107XG5cbiAgcmV0dXJuIHRzLmNyZWF0ZUNhbGwobm9kZS5leHByZXNzaW9uLCBub2RlLnR5cGVBcmd1bWVudHMsIGFyZ3MpO1xufVxuIl19